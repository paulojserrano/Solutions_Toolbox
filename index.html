<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASRS Designer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        /* Ensure canvas is responsive and doesn't overflow */
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .helper-text {
            font-size: 0.75rem; /* text-xs */
            color: #64748b; /* slate-500 */
            margin-top: -4px; /* Pull it closer to the input */
        }

        /* --- Main Tab Styles --- */
        .main-tab-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: #475569; /* slate-600 */
            border-bottom: 4px solid transparent;
            cursor: pointer;
            white-space: nowrap;
        }
        .main-tab-button.active {
            color: #2563eb; /* blue-600 */
            border-bottom-color: #2563eb; /* blue-600 */
        }
        .main-tab-content {
            display: none;
        }
        /* Config/Solver tab is block (scrolls) */
        .main-tab-content#configTabContent.active,
        .main-tab-content#solverTabContent.active {
            display: block;
        }
        /* Viz tab is flex (fills space) */
        .main-tab-content#vizTabContent.active {
            display: flex;
            flex-direction: column;
            flex: 1; /* Make the active tab content fill the space */
        }


        /* --- Sub-Tab Styles (within viz) --- */
        .sub-tab-button {
            padding: 0.75rem 1.25rem;
            font-weight: 500;
            color: #475569; /* slate-600 */
            border-bottom: 3px solid transparent;
            cursor: pointer;
            white-space: nowrap;
        }
        .sub-tab-button.active {
            color: #2563eb; /* blue-600 */
            border-bottom-color: #2563eb; /* blue-6Other */
        }
        .sub-tab-content {
            display: none;
        }
        .sub-tab-content.active {
            display: flex; /* Changed from block */
            flex-direction: column;
            flex: 1; /* Make the active tab content fill the space */
        }

        /* Style for elevation drawing */
        .elevation-label {
            font-size: 10px;
            font-weight: 500;
            fill: #1e293b; /* slate-800 */
        }
        .elevation-error-text {
            font-size: 16px;
            fill: #dc2626; /* red-600 */
            font-weight: 600;
        }

        /* --- Solver Modal Styles --- */
        #solverModal {
            background-color: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<!-- BODY is now h-screen and overflow-hidden -->
<body class="bg-slate-200 h-screen flex flex-col font-sans overflow-hidden">

    <!-- Header -->
    <header class="bg-slate-800 text-white shadow-lg z-10">
        <div class="w-full max-w-screen-2xl mx-auto p-4 md:p-6 flex items-center gap-4">
            <!-- Logo Placeholder -->
            <svg class="h-8 w-8 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25L3 7.5m18 0v9l-9 5.25L3 16.5v-9m9 5.25v9l-9-5.25m9 5.25v-9l9-5.25" />
            </svg>
            <h1 class="text-xl md:text-2xl font-bold">
                ASRS Designer
            </h1>
        </div>
    </header>

    <!-- Main Content Area (now a flex column) -->
    <main class="flex-1 w-full max-w-screen-2xl mx-auto p-4 md:p-6 flex flex-col gap-6 overflow-hidden">

        <!-- 1. NEW Main Tab Navigation -->
        <nav class="bg-white rounded-lg shadow-lg -mb-2">
            <div class="border-b border-slate-200 overflow-x-auto" id="mainViewTabs">
                <div class="flex">
                    <button class="main-tab-button active" data-tab="configTabContent">Configuration</button>
                    <button class="main-tab-button" data-tab="vizTabContent">Visualization</button>
                    <button class="main-tab-button" data-tab="solverTabContent">Solver</button>
                </div>
            </div>
        </nav>

        <!-- 2. NEW Main Tab Content: Configuration (scrolls) -->
        <div id="configTabContent" class="main-tab-content active space-y-6 overflow-y-auto">
            <!-- Inputs Panel -->
            <section class="bg-white p-6 rounded-lg shadow-lg">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-x-6 gap-y-4">
                    
                    <!-- Col 1: Warehouse Constraints -->
                    <div>
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            1. Warehouse
                        </h2>
                        <div class="grid grid-cols-1 gap-x-4 gap-y-5">
                            <!-- System Length -->
                            <div>
                                <label for="systemLength" class="block text-sm font-medium text-slate-700 mb-1">Length (mm)</label>
                                <input type="text" id="systemLength" value="30,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- System Width -->
                            <div>
                                <label for="systemWidth" class="block text-sm font-medium text-slate-700 mb-1">Width (mm)</label>
                                <input type="text" id="systemWidth" value="25,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Clear Height -->
                            <div>
                                <label for="clearHeight" class="block text-sm font-medium text-slate-700 mb-1">Clear Height (mm)</label>
                                <input type="text" id="clearHeight" value="10,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">For elevation view</p>
                            </div>
                        </div>
                    </div>

                    <!-- Col 2: Rack Specifications (Tote) -->
                    <div>
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            2. Rack Specs (Tote)
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-1 gap-x-4 gap-y-5">
                            <!-- Tote Width -->
                            <div>
                                <label for="toteWidth" class="block text-sm font-medium text-slate-700 mb-1">Tote Width (mm)</label>
                                <input type="text" id="toteWidth" value="650" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Along bay depth</p>
                            </div>
                            <!-- Tote Length -->
                            <div>
                                <label for="toteLength" class="block text-sm font-medium text-slate-700 mb-1">Tote Length (mm)</label>
                                <input type="text" id="toteLength" value="450" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Along bay width</p>
                            </div>
                            <!-- Tote Height (New) -->
                            <div>
                                <label for="toteHeight" class="block text-sm font-medium text-slate-700 mb-1">Tote Height (mm)</label>
                                <input type="text" id="toteHeight" value="300" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">For elevation view</p>
                            </div>
                            <!-- Totes per Bay -->
                            <div>
                                <label for="toteQtyPerBay" class="block text-sm font-medium text-slate-700 mb-1">Totes per Bay (Qty)</label>
                                <input type="text" id="toteQtyPerBay" value="4" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Horizontally</p>
                            </div>
                            <!-- Totes Deep -->
                            <div>
                                <label for="totesDeep" class="block text-sm font-medium text-slate-700 mb-1">Totes Deep (Qty)</label>
                                <select id="totesDeep" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                    <option value="1">1</option>
                                    <option value="2" selected>2</option>
                                    <option value="3">3</option>
                                </select>
                            </div>
                            <!-- Tote to Tote Distance -->
                            <div>
                                <label for="toteToToteDist" class="block text-sm font-medium text-slate-700 mb-1">Tote-to-Tote (mm)</label>
                                <input type="text" id="toteToToteDist" value="40" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Horizontal gap</p>
                            </div>
                            <!-- Tote to Upright Distance -->
                            <div>
                                <label for="toteToUprightDist" class="block text-sm font-medium text-slate-700 mb-1">Tote-to-Upright (mm)</label>
                                <input type="text" id="toteToUprightDist" value="70" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Side gap</p>
                            </div>
                            <!-- Tote Back to Back Distance -->
                            <div>
                                <label for="toteBackToBackDist" class="block text-sm font-medium text-slate-700 mb-1">Tote Back-to-Back (mm)</label>
                                <input type="text" id="toteBackToBackDist" value="0" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Depth gap</p>
                            </div>
                        </div>
                    </div>

                    <!-- Col 3: Rack Specifications (Structure) -->
                    <div>
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            2. Rack Specs (Structure)
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-1 gap-x-4 gap-y-5">
                            <!-- Upright Length -->
                            <div>
                                <label for="uprightLength" class="block text-sm font-medium text-slate-700 mb-1">Upright Length (mm)</label>
                                <input type="text" id="uprightLength" value="90" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Along bay width</p>
                            </div>
                            <!-- Upright Width -->
                            <div>
                                <label for="uprightWidth" class="block text-sm font-medium text-slate-700 mb-1">Upright Width (mm)</label>
                                <input type="text" id="uprightWidth" value="70" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Along bay depth</p>
                            </div>
                            <!-- Hook Allowance -->
                            <div>
                                <label for="hookAllowance" class="block text-sm font-medium text-slate-700 mb-1">Hook Allowance (mm)</label>
                                <input type="text" id="hookAllowance" value="90" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Vertical addition</p>
                            </div>
                            <!-- Aisle Width -->
                            <div>
                                <label for="aisleWidth" class="block text-sm font-medium text-slate-700 mb-1">Aisle Width (mm)</label>
                                <input type="text" id="aisleWidth" value="1,500" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Top Setback -->
                            <div>
                                <label for="setbackTop" class="block text-sm font-medium text-slate-700 mb-1">Top Setback (mm)</label>
                                <input type="text" id="setbackTop" value="3,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Bottom Setback -->
                            <div>
                                <label for="setbackBottom" class="block text-sm font-medium text-slate-700 mb-1">Bottom Setback (mm)</label>
                                <input type="text" id="setbackBottom" value="3,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Layout Mode -->
                            <div>
                                <label for="layoutMode" class="block text-sm font-medium text-slate-700 mb-1">Layout Mode</label>
                                <select id="layoutMode" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                    <option value="s-d-s">Single-Double-Single</option>
                                    <option value="all-singles">All Singles</option>
                                </select>
                            </div>
                            <!-- Flue Space (Conditional) -->
                            <div id="flueSpaceContainer">
                                <label for="flueSpace" class="block text-sm font-medium text-slate-700 mb-1">Rack Flue Space (mm)</label>
                                <input type="text" id="flueSpace" value="150" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Between double racks</p>
                            </div>
                        </div>
                    </div>

                    <!-- Col 4: Vertical & Performance -->
                    <div>
                        <!-- Vertical Constraints -->
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            3. Vertical
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-1 gap-x-4 gap-y-5 mb-6">
                            <!-- Base Beam Height -->
                            <div>
                                <label for="baseBeamHeight" class="block text-sm font-medium text-slate-700 mb-1">Base Beam Height (mm)</label>
                                <input type="text" id="baseBeamHeight" value="430" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Beam Width -->
                            <div>
                                <label for="beamWidth" class="block text-sm font-medium text-slate-700 mb-1">Beam Width (mm)</label>
                                <input type="text" id="beamWidth" value="60" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Vertical dimension of beam</p>
                            </div>
                            <!-- Tote Clearance -->
                            <div>
                                <label for="minClearance" class="block text-sm font-medium text-slate-700 mb-1">Tote Clearance (mm)</label>
                                <input type="text" id="minClearance" value="40" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Above tote to next beam</p>
                            </div>
                            <!-- Overhead Clearance -->
                            <div>
                                <label for="overheadClearance" class="block text-sm font-medium text-slate-700 mb-1">Overhead Clearance (mm)</label>
                                <input type="text" id="overheadClearance" value="915" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">Top tote to ceiling</p>
                            </div>
                            <!-- Sprinkler Threshold -->
                            <div>
                                <label for="sprinklerThreshold" class="block text-sm font-medium text-slate-700 mb-1">Sprinkler Threshold (mm)</label>
                                <input type="text" id="sprinklerThreshold" value="4000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Sprinkler Clearance -->
                            <div>
                                <label for="sprinklerClearance" class="block text-sm font-medium text-slate-700 mb-1">Sprinkler Clearance (mm)</label>
                                <input type="text" id="sprinklerClearance" value="500" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                        </div>
                        
                        <!-- Performance Requirements -->
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            4. Performance
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-1 gap-x-4 gap-y-5">
                            <!-- Inbound Presentations per Hour -->
                            <div>
                                <label for="inboundPPH" class="block text-sm font-medium text-slate-700 mb-1">Inbound PPH</label>
                                <input type="text" id="inboundPPH" value="500" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Outbound Presentations per Hour -->
                            <div>
                                <label for="outboundPPH" class="block text-sm font-medium text-slate-700 mb-1">Outbound PPH</label>
                                <input type="text" id="outboundPPH" value="500" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <!-- Inbound Workstation Rate -->
                            <div>
                                <label for="inboundWSRate" class="block text-sm font-medium text-slate-700 mb-1">Inbound WS Rate</LabeL>
                                <input type="text" id="inboundWSRate" value="100" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-5Choose">
                            </div>
                            <!-- Outbound Workstation Rate -->
                            <div>
                                <label for="outboundWSRate" class="block text-sm font-medium text-slate-700 mb-1">Outbound WS Rate</LabeL>
                                <input type="text" id="outboundWSRate" value="100" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                        </div>
                    </div>

                </div>
            </section>

            <!-- Results Panel (now in config tab) -->
            <section class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-4">
                    Results
                </h2>
                <div class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-7 gap-x-4 gap-y-6">
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Total Bays</span>
                        <span id="summaryTotalBays" class="text-2xl font-bold text-blue-600">0</span>
                    </div>
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Max Levels</span>
                        <span id="summaryMaxLevels" class="text-2xl font-bold text-blue-600">0</span>
                    </div>
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Total Locations</span>
                        <span id="summaryTotalLocations" class="text-2xl font-bold text-blue-600">0</span>
                    </div>
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Footprint (m²)</span>
                        <span id="summaryFootprint" class="text-2xl font-bold text-blue-600">0</span>
                    </div>
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Perf. Density (PPH / m²)</span>
                        <span id="summaryPerfDensity" class="text-2xl font-bold text-blue-600">0.0</span>
                    </div>
                    <!-- Solver Results -->
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Req. Inbound WS</span>
                        <span id="summaryInboundWS" class="text-2xl font-bold text-green-600">0</span>
                    </div>
                    <div>
                        <span class="block text-sm font-medium text-slate-500">Req. Outbound WS</span>
                        <span id="summaryOutboundWS" class="text-2xl font-bold text-green-600">0</span>
                    </div>
                </div>
            </section>
        </div>


        <!-- 3. NEW Main Tab Content: Visualization (fills space) -->
        <div id="vizTabContent" class="main-tab-content">
            <!-- Visualization Panel (now fills the tab) -->
            <section class="bg-white p-6 rounded-lg shadow-lg flex-1 flex flex-col overflow-hidden">
                <!-- Sub-Tab Navigation -->
                <div class="border-b border-slate-300 mb-4 overflow-x-auto">
                    <nav class="-mb-px flex gap-4" id="viewSubTabs">
                        <button class="sub-tab-button active" data-tab="topDownView">Top-Down View</button>
                        <button class="sub-tab-button" data-tab="rackDetailView">Rack Detail View</button>
                        <button class="sub-tab-button" data-tab="elevationView">Elevation View</button>
                        <!-- Removed Side Elevation Tab Button -->
                    </nav>
                </div>
                
                <!-- Sub-Tab Content -->
                <!-- Top-Down View Content -->
                <div id="topDownView" class="sub-tab-content active">
                    <div class="flex-1 w-full bg-slate-50 rounded-md overflow-hidden">
                        <canvas id="warehouseCanvas"></canvas>
                    </div>
                </div>
                
                <!-- Rack Detail View Content -->
                <div id="rackDetailView" class="sub-tab-content">
                     <div class="flex-1 w-full bg-slate-50 rounded-md overflow-hidden">
                         <canvas id="rackDetailCanvas"></canvas>
                    </div>
                </div>

                <!-- Elevation View Content (now holds both) -->
                <div id="elevationView" class="sub-tab-content">
                     <div class="flex-1 w-full bg-slate-50 rounded-md overflow-hidden">
                         <canvas id="elevationCanvas"></canvas>
                    </div>
                </div>

                <!-- Removed Side Elevation Tab Content -->
            </section>
        </div>

        <!-- 4. NEW Main Tab Content: Solver (scrolls) -->
        <div id="solverTabContent" class="main-tab-content space-y-6 overflow-y-auto">
            <section class="bg-white p-6 rounded-lg shadow-lg">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12">
                    
                    <!-- Col 1: Solver Inputs & Controls -->
                    <div>
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            Solver Inputs
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-5">
                            <div>
                                <label for="solverStorageReq" class="block text-sm font-medium text-slate-700 mb-1">Storage Requirement (Locations)</label>
                                <input type="text" id="solverStorageReq" value="30,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <div>
                                <label for="solverThroughputReq" class="block text-sm font-medium text-slate-700 mb-1">Throughput Requirement (Total PPH)</label>
                                <input type="text" id="solverThroughputReq" value="2,000" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                            <div>
                                <label for="solverAspectRatio" class="block text-sm font-medium text-slate-700 mb-1">Aspect Ratio (L / W)</label>
                                <input type="text" id="solverAspectRatio" value="1.5" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                <p class="helper-text">e.g., 1.5 for (L = 1.5 * W)</p>
                            </div>
                            <div>
                                <label for="solverMaxPerfDensity" class="block text-sm font-medium text-slate-700 mb-1">Max Performance Density (PPH/m²)</label>
                                <input type="text" id="solverMaxPerfDensity" value="50" class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            </div>
                        </div>
                        <div class="mt-6">
                            <button id="runSolverButton" class="w-full bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 disabled:opacity-50">
                                Run Solver
                            </button>
                            <p id="solverStatus" class="text-center text-slate-600 mt-3 h-5"></p>
                        </div>
                    </div>

                    <!-- Col 2: Solver Results -->
                    <div>
                        <h2 class="text-lg font-semibold text-slate-900 border-b border-slate-300 pb-3 mb-5">
                            Solver Results
                        </h2>
                        <div class="grid grid-cols-2 sm:grid-cols-3 gap-x-4 gap-y-6">
                            <div>
                                <span class="block text-sm font-medium text-slate-500">Solved Length (mm)</span>
                                <span id="solverResultLength" class="text-2xl font-bold text-blue-600">0</span>
                            </div>
                            <div>
                                <span class="block text-sm font-medium text-slate-500">Solved Width (mm)</span>
                                <span id="solverResultWidth" class="text-2xl font-bold text-blue-600">0</span>
                            </div>
                            <div>
                                <span class="block text-sm font-medium text-slate-500">Resulting Footprint (m²)</span>
                                <span id="solverResultFootprint" class="text-2xl font-bold text-blue-600">0</span>
                            </div>
                            <div>
                                <span class="block text-sm font-medium text-slate-500">Resulting Locations</span>
                                <span id="solverResultLocations" class="text-2xl font-bold text-blue-600">0</span>
                            </div>
                            <div>
                                <span class="block text-sm font-medium text-slate-500">Resulting Perf. Density</span>
                                <span id="solverResultPerfDensity" class="text-2xl font-bold text-blue-600">0.0</span>
                            </div>
                        </div>
                        <div class="mt-6">
                             <button id="applySolverButton" class="w-full bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                                Apply to Configuration
                            </button>
                        </div>
                    </div>
                </div>
            </section>
        </div>

    </main>

    <!-- NEW: Solver Modal -->
    <div id="solverModal" class="fixed inset-0 z-50 flex items-center justify-center p-4" style="display: none;">
        <div class="absolute inset-0" id="solverModalBackdrop"></div>
        <div class="relative bg-white w-full max-w-lg p-6 rounded-lg shadow-xl">
            <h3 class="text-xl font-semibold text-slate-900 mb-4">Solver Warning</h3>
            <p id="solverModalMessage" class="text-slate-600 mb-6">
                <!-- Message injected by JS -->
            </p>
            <div class="flex justify-end gap-4">
                <button id="solverModalStop" class="px-6 py-2 rounded-lg bg-slate-200 text-slate-800 font-medium hover:bg-slate-300">
                    No, Use Current Size
                </button>
                <button id="solverModalContinue" class="px-6 py-2 rounded-lg bg-blue-600 text-white font-medium hover:bg-blue-700">
                    Yes, Continue
                </button>
            </div>
        </div>
    </div>


    <!-- JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Global state for solver ---
            let solverTempResults = null;
            let solverFinalResults = null;

            // --- Number Formatting Helpers ---
            function formatNumber(numStr) {
                if (numStr === '' || numStr === null) return '';
                // Remove non-numeric characters except decimal point
                let num = parseFloat(numStr.toString().replace(/[^0-9.]/g, ''));
                if (isNaN(num)) return '';
                // Format with commas, no decimals
                return Math.round(num).toLocaleString('en-US');
            }

            function parseNumber(str) {
                if (str === '' || str === null) return 0;
                // Remove commas
                let num = parseFloat(str.toString().replace(/,/g, ''));
                if (isNaN(num)) return 0;
                return num;
            }

            // --- Get All Inputs ---
            // Warehouse Constraints
            const systemLengthInput = document.getElementById('systemLength');
            const systemWidthInput = document.getElementById('systemWidth');
            const clearHeightInput = document.getElementById('clearHeight');
            // Rack Specifications
            const toteWidthInput = document.getElementById('toteWidth');
            const toteLengthInput = document.getElementById('toteLength');
            const toteHeightInput = document.getElementById('toteHeight'); // New
            const toteQtyPerBayInput = document.getElementById('toteQtyPerBay');
            const totesDeepSelect = document.getElementById('totesDeep');
            const toteToToteDistInput = document.getElementById('toteToToteDist');
            const toteToUprightDistInput = document.getElementById('toteToUprightDist');
            const toteBackToBackDistInput = document.getElementById('toteBackToBackDist');
            const uprightLengthInput = document.getElementById('uprightLength');
            const uprightWidthInput = document.getElementById('uprightWidth');
            const hookAllowanceInput = document.getElementById('hookAllowance');
            const aisleWidthInput = document.getElementById('aisleWidth');
            const setbackTopInput = document.getElementById('setbackTop');
            const setbackBottomInput = document.getElementById('setbackBottom');
            const layoutModeSelect = document.getElementById('layoutMode');
            const flueSpaceInput = document.getElementById('flueSpace');
            const flueSpaceContainer = document.getElementById('flueSpaceContainer');
            // Vertical Constraints (New)
            const baseBeamHeightInput = document.getElementById('baseBeamHeight');
            const beamWidthInput = document.getElementById('beamWidth');
            const minClearanceInput = document.getElementById('minClearance');
            const overheadClearanceInput = document.getElementById('overheadClearance');
            const sprinklerThresholdInput = document.getElementById('sprinklerThreshold');
            const sprinklerClearanceInput = document.getElementById('sprinklerClearance');
            // Performance
            const inboundPPHInput = document.getElementById('inboundPPH');
            const outboundPPHInput = document.getElementById('outboundPPH');
            const inboundWSRateInput = document.getElementById('inboundWSRate');
            const outboundWSRateInput = document.getElementById('outboundWSRate');
            
            // Get summary elements
            const summaryTotalBays = document.getElementById('summaryTotalBays');
            const summaryMaxLevels = document.getElementById('summaryMaxLevels'); // New
            const summaryTotalLocations = document.getElementById('summaryTotalLocations'); // New
            const summaryFootprint = document.getElementById('summaryFootprint');
            const summaryPerfDensity = document.getElementById('summaryPerfDensity');
            const summaryInboundWS = document.getElementById('summaryInboundWS');
            const summaryOutboundWS = document.getElementById('summaryOutboundWS');

            // Get Canvases and Contexts
            const warehouseCanvas = document.getElementById('warehouseCanvas');
            const warehouseCtx = warehouseCanvas.getContext('2d');
            const rackDetailCanvas = document.getElementById('rackDetailCanvas');
            const rackDetailCtx = rackDetailCanvas.getContext('2d');
            const elevationCanvas = document.getElementById('elevationCanvas'); // New
            const elevationCtx = elevationCanvas.getContext('2d'); // New
            
            // Get Tab elements
            const mainViewTabs = document.getElementById('mainViewTabs'); // NEW
            const viewSubTabs = document.getElementById('viewSubTabs'); // Renamed
            
            // --- NEW: Solver Elements ---
            const solverStorageReqInput = document.getElementById('solverStorageReq');
            const solverThroughputReqInput = document.getElementById('solverThroughputReq');
            const solverAspectRatioInput = document.getElementById('solverAspectRatio');
            const solverMaxPerfDensityInput = document.getElementById('solverMaxPerfDensity');
            const runSolverButton = document.getElementById('runSolverButton');
            const solverStatus = document.getElementById('solverStatus');
            const solverResultLength = document.getElementById('solverResultLength');
            const solverResultWidth = document.getElementById('solverResultWidth');
            const solverResultFootprint = document.getElementById('solverResultFootprint');
            const solverResultLocations = document.getElementById('solverResultLocations');
            const solverResultPerfDensity = document.getElementById('solverResultPerfDensity');
            const applySolverButton = document.getElementById('applySolverButton');
            const solverModal = document.getElementById('solverModal');
            const solverModalMessage = document.getElementById('solverModalMessage');
            const solverModalContinue = document.getElementById('solverModalContinue');
            const solverModalStop = document.getElementById('solverModalStop');
            const solverModalBackdrop = document.getElementById('solverModalBackdrop');


            let rafId = null; // Single RAF ID for debouncing all draw calls
            
            // NEW: Global state for combined results
            let calculationResults = {
                totalBays: 0,
                maxLevels: 0
            };

            // Inputs that trigger a redraw
            const redrawInputs = [
                systemLengthInput, systemWidthInput, clearHeightInput,
                toteWidthInput, toteLengthInput, toteHeightInput, // Added toteHeight
                toteQtyPerBayInput, totesDeepSelect,
                toteToToteDistInput, toteToUprightDistInput, toteBackToBackDistInput,
                uprightLengthInput, uprightWidthInput, hookAllowanceInput,
                aisleWidthInput, setbackTopInput, setbackBottomInput,
                layoutModeSelect, flueSpaceInput,
                // Add new vertical inputs
                baseBeamHeightInput, beamWidthInput, minClearanceInput,
                overheadClearanceInput, sprinklerThresholdInput, sprinklerClearanceInput,
                // Add performance inputs, as they trigger results recalculation
                inboundPPHInput, outboundPPHInput, 
                inboundWSRateInput, outboundWSRateInput
            ];

            // All inputs that need number formatting
            const numberInputs = [
                systemLengthInput, systemWidthInput, clearHeightInput,
                toteWidthInput, toteLengthInput, toteHeightInput, // Added toteHeight
                toteQtyPerBayInput,
                toteToToteDistInput, toteToUprightDistInput, toteBackToBackDistInput,
                uprightLengthInput, uprightWidthInput, hookAllowanceInput,
                aisleWidthInput, setbackTopInput, setbackBottomInput, flueSpaceInput,
                // Add new vertical inputs
                baseBeamHeightInput, beamWidthInput, minClearanceInput,
                overheadClearanceInput, sprinklerThresholdInput, sprinklerClearanceInput,
                // Add performance inputs
                inboundPPHInput, outboundPPHInput, inboundWSRateInput, outboundWSRateInput,
                // Add solver inputs
                solverStorageReqInput, solverThroughputReqInput, solverAspectRatioInput, solverMaxPerfDensityInput
            ];

            // --- Helper Function to Toggle Flue Space Input ---
            function toggleFlueSpace() {
                if (layoutModeSelect.value === 's-d-s') {
                    flueSpaceContainer.style.display = 'block';
                } else {
                    flueSpaceContainer.style.display = 'none';
                }
            }
            
            // --- Helper Function to Draw a Rack (Top-Down View) ---
            function drawRack(x_world, rackDepth_world, rackType, params) {
                const {
                    ctx, scale, offsetX, offsetY,
                    bayWidth, bayDepth, // Note: bayDepth is calculated rack depth
                    flueSpace,
                    usableLength_world, setbackTop_world
                } = params;

                const rackX_canvas = offsetX + (x_world * scale);
                // Calculate Y start and height based on setbacks
                const rackY_canvas = offsetY + (setbackTop_world * scale);
                const rackHeight_canvas = usableLength_world * scale;

                if (rackHeight_canvas <= 0) return; // Don't draw if no height

                if (rackType === 'single') {
                    const rackWidth_canvas = rackDepth_world * scale;
                    
                    ctx.fillStyle = '#cbd5e1'; // slate-300
                    ctx.fillRect(rackX_canvas, rackY_canvas, rackWidth_canvas, rackHeight_canvas);
                    
                    if (bayWidth > 0) {
                        ctx.strokeStyle = '#94a3b8'; // slate-400
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        let currentBayY_world_relative = bayWidth; 
                        while (currentBayY_world_relative < usableLength_world) {
                            const bayY_canvas = rackY_canvas + (currentBayY_world_relative * scale);
                            ctx.moveTo(rackX_canvas, bayY_canvas);
                            ctx.lineTo(rackX_canvas + rackWidth_canvas, bayY_canvas);
                            currentBayY_world_relative += bayWidth;
                        }
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#64748b'; // slate-500
                    ctx.lineWidth = 1;
                    ctx.strokeRect(rackX_canvas, rackY_canvas, rackWidth_canvas, rackHeight_canvas);

                } else if (rackType === 'double') {
                    // This 'bayDepth' is the single rack depth from the new calculation
                    const rack1_width_canvas = bayDepth * scale;
                    const flue_width_canvas = flueSpace * scale;
                    const rack2_width_canvas = bayDepth * scale;
                    const rack2_x_canvas = rackX_canvas + rack1_width_canvas + flue_width_canvas;
                    
                    // --- Draw Rack 1 ---
                    ctx.fillStyle = '#cbd5e1'; // slate-300
                    ctx.fillRect(rackX_canvas, rackY_canvas, rack1_width_canvas, rackHeight_canvas);
                    if (bayWidth > 0) {
                        ctx.strokeStyle = '#94a3b8'; // slate-400
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        let currentBayY_world_relative = bayWidth;
                        while (currentBayY_world_relative < usableLength_world) {
                            const bayY_canvas = rackY_canvas + (currentBayY_world_relative * scale);
                            ctx.moveTo(rackX_canvas, bayY_canvas);
                            ctx.lineTo(rackX_canvas + rack1_width_canvas, bayY_canvas);
                            currentBayY_world_relative += bayWidth;
                        }
                        ctx.stroke();
                    }
                    ctx.strokeStyle = '#64748b'; // slate-500
                    ctx.lineWidth = 1;
                    ctx.strokeRect(rackX_canvas, rackY_canvas, rack1_width_canvas, rackHeight_canvas);

                    // --- Draw Rack 2 ---
                    ctx.fillStyle = '#cbd5e1'; // slate-300
                    ctx.fillRect(rack2_x_canvas, rackY_canvas, rack2_width_canvas, rackHeight_canvas);
                     if (bayWidth > 0) {
                        ctx.strokeStyle = '#94a3b8'; // slate-400
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        let currentBayY_world_relative = bayWidth;
                        while (currentBayY_world_relative < usableLength_world) {
                            const bayY_canvas = rackY_canvas + (currentBayY_world_relative * scale);
                            ctx.moveTo(rack2_x_canvas, bayY_canvas);
                            ctx.lineTo(rack2_x_canvas + rack2_width_canvas, bayY_canvas);
                            currentBayY_world_relative += bayWidth;
                        }
                        ctx.stroke();
                    }
                    ctx.strokeStyle = '#64748b'; // slate-500
                    ctx.lineWidth = 1;
                    ctx.strokeRect(rack2_x_canvas, rackY_canvas, rack2_width_canvas, rackHeight_canvas);
                }
            }

            // --- Helper Function to Draw Dimensions (General) ---
            function drawDimensions(ctx, x1, y1, drawWidth, drawHeight, sysWidth_label, sysLength_label) {
                const extensionLength = 20;
                const textPadding = 10;
                
                ctx.strokeStyle = '#64748b'; // slate-500
                ctx.fillStyle = '#64748b'; // slate-500
                ctx.lineWidth = 1;
                ctx.font = '12px Inter, sans-serif';
                ctx.textBaseline = 'middle';

                // --- Horizontal (System Width) ---
                const y = y1 - extensionLength - textPadding;
                ctx.beginPath();
                ctx.moveTo(x1, y); ctx.lineTo(x1 + drawWidth, y); // Main line
                ctx.moveTo(x1, y - 5); ctx.lineTo(x1, y + 5); // Left tick
                ctx.moveTo(x1 + drawWidth, y - 5); ctx.lineTo(x1 + drawWidth, y + 5); // Right tick
                ctx.stroke();
                
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(sysWidth_label).toLocaleString('en-US')} mm`, x1 + drawWidth / 2, y - textPadding);

                // --- Vertical (System Length) ---
                const x = x1 - extensionLength - textPadding;
                ctx.beginPath();
                ctx.moveTo(x, y1); ctx.lineTo(x, y1 + drawHeight); // Main line
                ctx.moveTo(x - 5, y1); ctx.lineTo(x + 5, y1); // Top tick
                ctx.moveTo(x - 5, y1 + drawHeight); ctx.lineTo(x + 5, y1 + drawHeight); // Bottom tick
                ctx.stroke();

                // Rotated text
                ctx.save();
                ctx.translate(x - textPadding, y1 + drawHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(sysLength_label).toLocaleString('en-US')} mm`, 0, 0);
                ctx.restore();
            }

            // --- Layout Calculation Function (Top-Down) ---
            function calculateLayout(bayWidth, bayDepth, aisleWidth, sysLength, sysWidth, layoutMode, flueSpace, setbackTop, setbackBottom) {
                let layoutItems = [];
                let totalBays = 0;
                let currentX_world = 0;

                // Calculate usable length based on setbacks
                let usableLength = sysLength - setbackTop - setbackBottom;
                if (usableLength <= 0) usableLength = 0;

                const baysPerRack = (bayWidth > 0 && usableLength > 0) ? Math.floor(usableLength / bayWidth) : 0;

                if (layoutMode === 'all-singles') {
                    const rackWidth = bayDepth; // bayDepth is the calculated single rack depth
                    const itemWidth = rackWidth + aisleWidth;

                    // 1. Check if we can fit at least one rack
                    if (sysWidth >= rackWidth) {
                        // Add first rack
                        layoutItems.push({ type: 'rack', x: 0, width: rackWidth, rackType: 'single' });
                        totalBays += baysPerRack;
                        currentX_world += rackWidth;
                    } else {
                        // Not enough room for even one rack
                        return { layoutItems: [], totalBays: 0, totalLayoutWidth: 0, usableLength: 0 };
                    }

                    // 2. Loop, adding [Aisle] + [Rack]
                    while (currentX_world + aisleWidth + rackWidth <= sysWidth) {
                        layoutItems.push({ type: 'aisle', x: currentX_world, width: aisleWidth });
                        currentX_world += aisleWidth;

                        layoutItems.push({ type: 'rack', x: currentX_world, width: rackWidth, rackType: 'single' });
                        totalBays += baysPerRack;
                        currentX_world += rackWidth;
                    }
                } 
                else if (layoutMode === 's-d-s') {
                    const singleRackWidth = bayDepth; // calculated single rack depth
                    const doubleRackWidth = (bayDepth * 2) + flueSpace; // flueSpace is RACK flue

                    // 1. Try to add first [Single Rack]
                    if (currentX_world + singleRackWidth <= sysWidth) {
                        layoutItems.push({ type: 'rack', x: 0, width: singleRackWidth, rackType: 'single' });
                        totalBays += baysPerRack;
                        currentX_world += singleRackWidth;
                    } else {
                         return { layoutItems: [], totalBays: 0, totalLayoutWidth: 0, usableLength: 0 };
                    }

                    // 2. Loop, adding [Aisle] + [Double Rack]
                    while (currentX_world + aisleWidth + doubleRackWidth + aisleWidth + singleRackWidth <= sysWidth) {
                        layoutItems.push({ type: 'aisle', x: currentX_world, width: aisleWidth });
                        currentX_world += aisleWidth;

                        layoutItems.push({ type: 'rack', x: currentX_world, width: doubleRackWidth, rackType: 'double' });
                        totalBays += (baysPerRack * 2); // Double rack has two rows of bays
                        currentX_world += doubleRackWidth;
                    }

                    // 3. Try to add final [Aisle] + [Single Rack]
                    if (currentX_world + aisleWidth + singleRackWidth <= sysWidth) {
                         layoutItems.push({ type: 'aisle', x: currentX_world, width: aisleWidth });
                        currentX_world += aisleWidth;

                        layoutItems.push({ type: 'rack', x: currentX_world, width: singleRackWidth, rackType: 'single' });
                        totalBays += baysPerRack;
                        currentX_world += singleRackWidth;
                    }
                }

                const lastItem = layoutItems[layoutItems.length - 1];
                const totalLayoutWidth = lastItem ? lastItem.x + lastItem.width : 0;

                return { layoutItems, totalBays, totalLayoutWidth, usableLength };
            }


            // --- Main Drawing Function (Top-Down) ---
            function drawWarehouse() {
                const dpr = window.devicePixelRatio || 1;
                
                // --- FIX: Read client dimensions ONCE ---
                const canvasWidth = warehouseCanvas.clientWidth;
                const canvasHeight = warehouseCanvas.clientHeight;

                // Prevent drawing if canvas is not visible
                if (canvasWidth === 0 || canvasHeight === 0) {
                    return;
                }
                
                warehouseCanvas.width = canvasWidth * dpr;
                warehouseCanvas.height = canvasHeight * dpr;
                
                // Reset the transformation matrix to identity
                warehouseCtx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Now apply the clean scale for HiDPI
                warehouseCtx.scale(dpr, dpr);
                
                // const canvasWidth = warehouseCanvas.clientWidth; // REMOVED
                // const canvasHeight = warehouseCanvas.clientHeight; // REMOVED

                warehouseCtx.clearRect(0, 0, canvasWidth, canvasHeight);

                // --- Get Values & Calculate Bay Dimensions (Using NEW Logic) ---
                const toteWidth = parseNumber(toteWidthInput.value) || 0; // Along bay depth
                const toteLength = parseNumber(toteLengthInput.value) || 0; // Along bay width
                const toteQtyPerBay = parseNumber(toteQtyPerBayInput.value) || 1; 
                const totesDeep = parseNumber(totesDeepSelect.value) || 1;
                const toteToToteDist = parseNumber(toteToToteDistInput.value) || 0;
                const toteToUprightDist = parseNumber(toteToUprightDistInput.value) || 0;
                const toteBackToBackDist = parseNumber(toteBackToBackDistInput.value) || 0;
                const uprightLength = parseNumber(uprightLengthInput.value) || 0;
                const uprightWidth = parseNumber(uprightWidthInput.value) || 0;
                const hookAllowance = parseNumber(hookAllowanceInput.value) || 0;

                // Bay Width (horizontal)
                const bayWidth = (toteQtyPerBay * toteLength) + 
                                 (2 * toteToUprightDist) + 
                                 (Math.max(0, toteQtyPerBay - 1) * toteToToteDist) + 
                                 (uprightLength * 2);
                
                // Bay Depth (vertical) for a SINGLE rack
                const bayDepth = (totesDeep * toteWidth) + 
                                 (Math.max(0, totesDeep - 1) * toteBackToBackDist) + 
                                 hookAllowance; // Use hook allowance
                
                // Get other values
                const aisleWidth = parseNumber(aisleWidthInput.value) || 0;
                const sysLength = parseNumber(systemLengthInput.value) || 0;
                const sysWidth = parseNumber(systemWidthInput.value) || 0;
                const setbackTop = parseNumber(setbackTopInput.value) || 0;
                const setbackBottom = parseNumber(setbackBottomInput.value) || 0;
                const layoutMode = layoutModeSelect.value;
                const flueSpace = parseNumber(flueSpaceInput.value) || 0;

                // --- Run Layout Calculation ---
                // Pass the *calculated* bayWidth and bayDepth
                const layout = calculateLayout(bayWidth, bayDepth, aisleWidth, sysLength, sysWidth, layoutMode, flueSpace, setbackTop, setbackBottom);
                
                // --- Update Results Panel ---
                calculationResults.totalBays = layout.totalBays; // Update global state
                summaryTotalBays.textContent = layout.totalBays.toLocaleString('en-US');

                // Get performance values
                const inboundPPH = parseNumber(inboundPPHInput.value) || 0;
                const outboundPPH = parseNumber(outboundPPHInput.value) || 0;
                // Get WS Rates
                const inboundWSRate = parseNumber(inboundWSRateInput.value) || 0;
                const outboundWSRate = parseNumber(outboundWSRateInput.value) || 0;
                
                // Calculate Footprint
                const footprintM2 = (sysLength / 1000) * (sysWidth / 1000);
                summaryFootprint.textContent = footprintM2.toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
                
                // Calculate Performance Density
                const totalPPH = inboundPPH + outboundPPH;
                const perfDensity = (footprintM2 > 0) ? totalPPH / footprintM2 : 0;
                summaryPerfDensity.textContent = perfDensity.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

                // --- Solver Calculation ---
                const reqInboundWS = (inboundWSRate > 0) ? Math.ceil(inboundPPH / inboundWSRate) : 0;
                const reqOutboundWS = (outboundWSRate > 0) ? Math.ceil(outboundPPH / outboundWSRate) : 0;
                summaryInboundWS.textContent = reqInboundWS.toLocaleString('en-US');
                summaryOutboundWS.textContent = reqOutboundWS.toLocaleString('en-US');

                // --- Calculate Scaling and Centering ---
                const padding = 80; // Generous padding for dimensions
                
                // Calculate scale to fit both width and height
                const scaleX = (canvasWidth - padding * 2) / sysWidth;
                const scaleY = (canvasHeight - padding * 2) / sysLength;
                const scale = Math.min(scaleX, scaleY);
                
                if (scale <= 0 || !isFinite(scale)) return; // Don't draw if no space or invalid scale

                // Calculate dimensions of the *drawing* (not canvas)
                const drawWidth = sysWidth * scale;
                const drawHeight = sysLength * scale;
                
                // Calculate offsets to center the *drawing*
                const drawOffsetX = (canvasWidth - drawWidth) / 2;
                const drawOffsetY = (canvasHeight - drawHeight) / 2;

                // --- Calculate Centering for the *Layout* ---
                // This centers the actual racks/aisles within the system footprint
                const layoutOffsetX_world = (sysWidth - layout.totalLayoutWidth) / 2;
                
                // Final offset = drawing offset + layout offset
                const offsetX = drawOffsetX + (layoutOffsetX_world * scale);
                const offsetY = drawOffsetY;

                // Create params object for the helper function
                const drawParams = {
                    ctx: warehouseCtx, scale, offsetX, offsetY, 
                    bayWidth, bayDepth, // Pass calculated values
                    flueSpace, sysLength,
                    usableLength_world: layout.usableLength,
                    setbackTop_world: setbackTop
                };

                // --- Start Drawing ---
                
                // Draw background footprint
                warehouseCtx.fillStyle = '#f8fafc'; // slate-50
                warehouseCtx.strokeStyle = '#64748b'; // slate-500
                warehouseCtx.lineWidth = 2;
                warehouseCtx.fillRect(drawOffsetX, drawOffsetY, drawWidth, drawHeight);
                warehouseCtx.strokeRect(drawOffsetX, drawOffsetY, drawWidth, drawHeight);

                // Draw layout items (racks and aisles)
                layout.layoutItems.forEach(item => {
                    if (item.type === 'rack') {
                        // drawRack 'bayDepth' param is rackDepth_world
                        drawRack(item.x, item.width, item.rackType, drawParams);
                    }
                    // We don't visually draw aisles, they are the empty space
                });

                // Draw Top and Bottom Setbacks
                if (setbackTop > 0) {
                    warehouseCtx.fillStyle = 'rgba(239, 68, 68, 0.1)'; // red-500 with 10% opacity
                    warehouseCtx.fillRect(drawOffsetX, drawOffsetY, drawWidth, setbackTop * scale);
                    warehouseCtx.strokeStyle = 'rgba(239, 68, 68, 0.4)';
                    warehouseCtx.setLineDash([5, 5]);
                    warehouseCtx.strokeRect(drawOffsetX, drawOffsetY, drawWidth, setbackTop * scale);
                    warehouseCtx.setLineDash([]);
                }
                if (setbackBottom > 0) {
                    const setbackY_canvas = drawOffsetY + (sysLength - setbackBottom) * scale;
                    warehouseCtx.fillStyle = 'rgba(239, 68, 68, 0.1)'; // red-500 with 10% opacity
                    warehouseCtx.fillRect(drawOffsetX, setbackY_canvas, drawWidth, setbackBottom * scale);
                    warehouseCtx.strokeStyle = 'rgba(239, 68, 68, 0.4)';
                    warehouseCtx.setLineDash([5, 5]);
                    warehouseCtx.strokeRect(drawOffsetX, setbackY_canvas, drawWidth, setbackBottom * scale);
                    warehouseCtx.setLineDash([]);
                }


                // Draw dimension lines
                drawDimensions(warehouseCtx, drawOffsetX, drawOffsetY, drawWidth, drawHeight, sysWidth, sysLength);
            }

            // --- Rack Detail Drawing Code ---

            // --- Refactored Drawing Helper: Structure ---
            function drawStructure(ctx, offsetX, offsetY, drawWidth, drawHeight, scale, params) {
                const { upLength_c, upWidth_c, uprightLength_world } = params;

                // --- Draw Uprights (4 corners, filled rectangles) ---
                ctx.fillStyle = '#64748b'; // slate-500
                // Top-left
                ctx.fillRect(offsetX, offsetY, upLength_c, upWidth_c);
                // Top-right
                ctx.fillRect(offsetX + drawWidth - upLength_c, offsetY, upLength_c, upWidth_c);
                // Bottom-left
                ctx.fillRect(offsetX, offsetY + drawHeight - upWidth_c, upLength_c, upWidth_c);
                // Bottom-right
                ctx.fillRect(offsetX + drawWidth - upLength_c, offsetY + drawHeight - upWidth_c, upLength_c, upWidth_c);

                // --- Draw Upright C-Channels (lines on top of filled uprights) ---
                ctx.strokeStyle = '#64748b'; // slate-500
                ctx.lineWidth = 2; 

                // Calculate offsets for two lines, centered in the upright
                const lineGap_world = 65;
                const margin_world = (uprightLength_world - lineGap_world) / 2;
                
                const line1_offset_c = margin_world * scale;
                const line2_offset_c = (margin_world + lineGap_world) * scale;
                
                // --- Left upright C-Channel ---
                const leftLine1_x = offsetX + line1_offset_c;
                const leftLine2_x = offsetX + line2_offset_c;
                
                ctx.beginPath();
                // Top cap
                ctx.moveTo(leftLine1_x, offsetY);
                ctx.lineTo(leftLine2_x, offsetY);
                // Bottom cap
                ctx.moveTo(leftLine1_x, offsetY + drawHeight);
                ctx.lineTo(leftLine2_x, offsetY + drawHeight);
                // Vertical web 1
                ctx.moveTo(leftLine1_x, offsetY);
                ctx.lineTo(leftLine1_x, offsetY + drawHeight);
                // Vertical web 2
                ctx.moveTo(leftLine2_x, offsetY);
                ctx.lineTo(leftLine2_x, offsetY + drawHeight);
                ctx.stroke();


                // --- Right upright C-Channel ---
                const rightUprightX_c = offsetX + drawWidth - upLength_c;
                const rightLine1_x = rightUprightX_c + line1_offset_c;
                const rightLine2_x = rightUprightX_c + line2_offset_c;

                ctx.beginPath();
                // Top cap
                ctx.moveTo(rightLine1_x, offsetY);
                ctx.lineTo(rightLine2_x, offsetY);
                // Bottom cap
                ctx.moveTo(rightLine1_x, offsetY + drawHeight);
                ctx.lineTo(rightLine2_x, offsetY + drawHeight);
                // Vertical web 1
                ctx.moveTo(rightLine1_x, offsetY);
                ctx.lineTo(rightLine1_x, offsetY + drawHeight);
                // Vertical web 2
                ctx.moveTo(rightLine2_x, offsetY);
                ctx.lineTo(rightLine2_x, offsetY + drawHeight);
                ctx.stroke();

                // --- Draw Horizontal Beams ---
                const beamGap_world = 40;
                const beamGap_c = beamGap_world * scale;
                const beam_x1 = offsetX + upLength_c; // Inner edge of left upright
                const beam_x2 = offsetX + drawWidth - upLength_c; // Inner edge of right upright

                ctx.beginPath();
                // Top beam (flush to top edge)
                const top_y1 = offsetY;
                const top_y2 = offsetY + beamGap_c;
                ctx.moveTo(beam_x1, top_y1);
                ctx.lineTo(beam_x2, top_y1);
                ctx.moveTo(beam_x1, top_y2);
                ctx.lineTo(beam_x2, top_y2);

                // Bottom beam (flush to bottom edge)
                const bottom_y1 = offsetY + drawHeight - beamGap_c;
                const bottom_y2 = offsetY + drawHeight;
                ctx.moveTo(beam_x1, bottom_y1);
                ctx.lineTo(beam_x2, bottom_y1);
                ctx.moveTo(beam_x1, bottom_y2);
                ctx.lineTo(beam_x2, bottom_y2);
                
                ctx.stroke();
            }

            // --- Refactored Drawing Helper: Totes ---
            function drawTotes(ctx, offsetX, offsetY, scale, params) {
                const {
                    totesDeep, toteQtyPerBay,
                    toteWidth_c, toteLength_c,
                    toteToTote_c, toteToUpright_c, toteBackToBack_c,
                    upLength_c
                } = params;
                
                ctx.fillStyle = '#adcce2'; // A lighter blue for totes to stand out
                ctx.strokeStyle = '#6495ed'; // A darker blue for tote outlines
                ctx.lineWidth = 1;

                let current_y_canvas = offsetY; // Start from very top edge
                for (let j = 0; j < totesDeep; j++) {
                    let current_x_canvas = offsetX + upLength_c + toteToUpright_c; // Offset by upright + toteToUpright
                    for (let i = 0; i < toteQtyPerBay; i++) {
                        // Draw with (width = toteLength_c, height = toteWidth_c)
                        ctx.fillRect(current_x_canvas, current_y_canvas, toteLength_c, toteWidth_c);
                        ctx.strokeRect(current_x_canvas, current_y_canvas, toteLength_c, toteWidth_c);
                        // Increment x by horizontal tote dimension (toteLength_c)
                        current_x_canvas += toteLength_c + toteToTote_c;
                    }
                    // Increment y by vertical tote dimension (toteWidth_c)
                    current_y_canvas += toteWidth_c + toteBackToBack_c;
                }
            }

            // --- Refactored Drawing Helper: Detail Dimensions ---
            function drawDetailDimensions(ctx, offsetX, offsetY, scale, params) {
                const {
                    toteWidth, toteLength, toteToToteDist, toteToUprightDist,
                    toteQtyPerBay, totesDeep,
                    toteWidth_c, toteLength_c, toteToTote_c, toteToUpright_c,
                    upLength_c
                } = params;

                // --- FIX: Declare vars at function scope ---
                let x1, x2, x1_tote, x2_tote, x1_gap, x2_gap;

                ctx.strokeStyle = '#ec4899'; // pink-500
                ctx.fillStyle = '#ec4899';
                ctx.lineWidth = 1;
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';

                // --- Draw Horizontal Detail Dims (Tote-Upright, Tote, Tote-Tote) ---
                if (toteQtyPerBay > 0) {
                    const y = offsetY + (toteWidth_c / 2); // Y-level for horizontal dims
                    let current_x = offsetX + upLength_c;

                    // 1. Tote-to-Upright
                    if (toteToUprightDist > 0) {
                        x1 = current_x; // Use assignment
                        x2 = current_x + toteToUpright_c; // Use assignment
                        ctx.beginPath();
                        ctx.moveTo(x1, y - 5); ctx.lineTo(x1, y + 5); // tick 1
                        ctx.moveTo(x2, y - 5); ctx.lineTo(x2, y + 5); // tick 2
                        ctx.moveTo(x1, y); ctx.lineTo(x2, y); // line
                        ctx.stroke();
                        ctx.fillText(`${toteToUprightDist}`, (x1 + x2) / 2, y - 10);
                        current_x = x2;
                    }

                    // 2. Tote Length (First Tote)
                    x1_tote = current_x; // Use assignment
                    x2_tote = current_x + toteLength_c; // Use assignment
                    ctx.beginPath();
                    ctx.moveTo(x1_tote, y - 5); ctx.lineTo(x1_tote, y + 5); // tick 1
                    ctx.moveTo(x2_tote, y - 5); ctx.lineTo(x2_tote, y + 5); // tick 2
                    ctx.moveTo(x1_tote, y); ctx.lineTo(x2_tote, y); // line
                    ctx.stroke();
                    ctx.fillText(`${toteLength}`, (x1_tote + x2_tote) / 2, y - 10);
                    current_x = x2_tote;

                    // 3. Tote-to-Tote (First Gap)
                    if (toteQtyPerBay > 1 && toteToToteDist > 0) {
                        x1_gap = current_x; // Use assignment
                        x2_gap = current_x + toteToTote_c; // Use assignment
                        ctx.beginPath();
                        ctx.moveTo(x1_gap, y - 5); ctx.lineTo(x1_gap, y + 5); // tick 1
                        ctx.moveTo(x2_gap, y - 5); ctx.lineTo(x2_gap, y + 5); // tick 2
                        ctx.moveTo(x1_gap, y); ctx.lineTo(x2_gap, y); // line
                        ctx.stroke();
                        ctx.fillText(`${toteToToteDist}`, (x1_gap + x2_gap) / 2, y - 10);
                    }
                }

                 // --- Draw Vertical Detail Dim (Tote Width) ---
                if (totesDeep > 0) {
                    // x position is just to the right of the first tote
                    const x = offsetX + upLength_c + toteToUpright_c + toteLength_c + 15; // Offset from right edge of tote
                    const y1 = offsetY; // y1 is the top edge of the first tote
                    const y2 = y1 + toteWidth_c; // y2 is y1 + vertical tote dimension

                    ctx.textBaseline = 'middle';
                    
                    ctx.beginPath();
                    ctx.moveTo(x - 5, y1); ctx.lineTo(x + 5, y1); // tick 1
                    ctx.moveTo(x - 5, y2); ctx.lineTo(x + 5, y2); // tick 2
                    ctx.moveTo(x, y1); ctx.lineTo(x, y2); // line
                    ctx.stroke();
                    
                    ctx.save();
                    ctx.translate(x + 10, (y1 + y2) / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.textAlign = 'center';
                    ctx.fillText(`${toteWidth} mm`, 0, 0);
                    ctx.restore();
                }
            }


            // --- Main Drawing Function (Rack Detail) ---
            function drawRackDetail() {
                const dpr = window.devicePixelRatio || 1;

                // --- FIX: Read client dimensions ONCE ---
                const canvasWidth = rackDetailCanvas.clientWidth;
                const canvasHeight = rackDetailCanvas.clientHeight;

                if (canvasWidth === 0 || canvasHeight === 0) return;
                
                rackDetailCanvas.width = canvasWidth * dpr;
                rackDetailCanvas.height = canvasHeight * dpr;
                rackDetailCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                rackDetailCtx.scale(dpr, dpr);
                
                // const canvasWidth = rackDetailCanvas.clientWidth; // REMOVED
                // const canvasHeight = rackDetailCanvas.clientHeight; // REMOVED
                const ctx = rackDetailCtx;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);


                // --- 1. Get Values ---
                const toteWidth = parseNumber(toteWidthInput.value) || 0;
                const toteLength = parseNumber(toteLengthInput.value) || 0;
                const toteQtyPerBay = parseNumber(toteQtyPerBayInput.value) || 1; 
                const totesDeep = parseNumber(totesDeepSelect.value) || 1;
                const toteToToteDist = parseNumber(toteToToteDistInput.value) || 0;
                const toteToUprightDist = parseNumber(toteToUprightDistInput.value) || 0;
                const toteBackToBackDist = parseNumber(toteBackToBackDistInput.value) || 0;
                const uprightLength = parseNumber(uprightLengthInput.value) || 0;
                const uprightWidth = parseNumber(uprightWidthInput.value) || 0;
                const hookAllowance = parseNumber(hookAllowanceInput.value) || 0;

                // --- 2. Calculate Bay Dimensions ---
                const bayWidth = (toteQtyPerBay * toteLength) + (2 * toteToUprightDist) + (Math.max(0, toteQtyPerBay - 1) * toteToToteDist) + (uprightLength * 2);
                const bayDepth_total = (totesDeep * toteWidth) + (Math.max(0, totesDeep - 1) * toteBackToBackDist) + hookAllowance;
                
                if (bayWidth === 0 || bayDepth_total === 0) return;

                // --- 3. Calculate Scaling and Centering ---
                const padding = 100; // Generous padding for detail dimensions
                const scaleX = (canvasWidth - padding * 2) / bayWidth;
                const scaleY = (canvasHeight - padding * 2) / bayDepth_total;
                const scale = Math.min(scaleX, scaleY);
                if (scale <= 0 || !isFinite(scale)) return;

                const drawWidth = bayWidth * scale;
                const drawHeight = bayDepth_total * scale;
                const offsetX = (canvasWidth - drawWidth) / 2;
                const offsetY = (canvasHeight - drawHeight) / 2;
                
                // --- 4. Create Parameters Object for Helpers ---
                const params = {
                    // World values
                    toteWidth, toteLength, toteToToteDist, toteToUprightDist, toteBackToBackDist,
                    toteQtyPerBay, totesDeep,
                    uprightLength_world: uprightLength,
                    
                    // Canvas-scaled values
                    upLength_c: uprightLength * scale,
                    upWidth_c: uprightWidth * scale,
                    toteWidth_c: toteWidth * scale,
                    toteLength_c: toteLength * scale,
                    toteToTote_c: toteToToteDist * scale,
                    toteToUpright_c: toteToUprightDist * scale,
                    toteBackToBack_c: toteBackToBackDist * scale
                };

                // --- 5. Execute Drawing Functions in Order ---
                
                // Draw structure first
                drawStructure(ctx, offsetX, offsetY, drawWidth, drawHeight, scale, params);
                
                // Draw totes on top of structure
                drawTotes(ctx, offsetX, offsetY, scale, params);

                // Draw overall dimensions
                drawDimensions(ctx, offsetX, offsetY, drawWidth, drawHeight, bayWidth, bayDepth_total);
                
                // Draw detail (pink) dimensions on top of everything
                drawDetailDimensions(ctx, offsetX, offsetY, scale, params);
            }

            // --- NEW: Elevation View Logic ---

            // Helper function for 50mm pitch rounding
            function roundUpTo50(value) {
                return Math.ceil(value / 50) * 50;
            }

            /**
             * Calculates the layout of rack levels.
             * Returns an array of level objects, or null if it fails.
             */
            function calculateElevationLayout(inputs, evenDistribution = false) {
                const { WH, BaseHeight, BW, TH, MC, OC, SC, ST } = inputs;
                
                if (WH <= 0 || BaseHeight < 0 || BW <= 0 || TH <= 0 || MC < 0 || OC < 0 || SC < 0 || ST <= 0) {
                    return null; // Invalid inputs
                }

                const MaxLoadHeight = WH - OC;
                if (MaxLoadHeight < BaseHeight + BW + TH) {
                    return { levels: [], N: 0, topToteHeight: 0 }; // Not even space for one level
                }


                let N = 0;
                let currentBeamBottom = BaseHeight;
                let currentToteTop = BaseHeight + BW + TH;
                let sprinklerLevelCount = 1;
                const levels = [];
                
                // --- PASS 1: Calculate MAX Capacity (always run) ---
                // This loop just stacks levels to find the max N and sprinkler count
                const capacityLayout = [];
                let maxN = 0;
                let numSprinklers = 0;
                let topToteHeightCapacity = 0;

                while (true) {
                    if (currentToteTop > MaxLoadHeight) {
                        break;
                    }

                    maxN++;
                    const levelInfo = {
                        beamBottom: currentBeamBottom,
                        beamTop: currentBeamBottom + BW,
                        toteTop: currentBeamBottom + BW + TH,
                        sprinklerAdded: 0
                    };
                    capacityLayout.push(levelInfo);
                    topToteHeightCapacity = levelInfo.toteTop;
                    
                    let requiredGap = MC;
                    // Check if *this* level's tote top exceeds the *current* sprinkler threshold
                    if (levelInfo.toteTop > (sprinklerLevelCount * ST)) {
                        requiredGap += SC;
                        levelInfo.sprinklerAdded = SC;
                        sprinklerLevelCount++;
                        numSprinklers++;
                    }
                    
                    const actualGap = roundUpTo50(requiredGap);
                    const nextBeamBottom = currentBeamBottom + BW + TH + actualGap;
                    const nextToteTop = nextBeamBottom + BW + TH;
                    
                    currentBeamBottom = nextBeamBottom;
                    currentToteTop = nextToteTop;
                }
                
                // If not trying even distribution, just return the capacity layout
                if (!evenDistribution || numSprinklers === 0) {
                    return { levels: capacityLayout, N: maxN, topToteHeight: topToteHeightCapacity };
                }

                // --- PASS 2: Calculate EVEN Distribution ---
                const levelsPerSprinklerGroup = Math.floor(maxN / (numSprinklers + 1));
                const remainderLevels = maxN % (numSprinklers + 1);
                
                const evenLayout = [];
                let levelCount = 0;
                let sprinklersPlaced = 0;
                currentBeamBottom = BaseHeight;
                currentToteTop = BaseHeight + BW + TH;
                
                for (let i = 1; i <= maxN; i++) {
                    const levelInfo = {
                        beamBottom: currentBeamBottom,
                        beamTop: currentBeamBottom + BW,
                        toteTop: currentBeamBottom + BW + TH,
                        sprinklerAdded: 0
                    };
                    evenLayout.push(levelInfo);
                    levelCount++;

                    let requiredGap = MC;
                    
                    // Check if this is the spot to place a sprinkler
                    if (sprinklersPlaced < numSprinklers) {
                        const currentGroupSize = levelsPerSprinklerGroup + (sprinklersPlaced < remainderLevels ? 1 : 0);
                        
                        if (levelCount === currentGroupSize) {
                            requiredGap += SC;
                            levelInfo.sprinklerAdded = SC;
                            sprinklersPlaced++;
                            levelCount = 0; // Reset for next group
                        }
                    }
                    
                    const actualGap = roundUpTo50(requiredGap);
                    
                    if (i < maxN) { // Don't calculate next position if we are on the last level
                        const nextBeamBottom = currentBeamBottom + BW + TH + actualGap;
                        const nextToteTop = nextBeamBottom + BW + TH;

                        // Check for fit
                        if (nextToteTop > MaxLoadHeight) {
                            // This "even" layout FAILED to fit.
                            // Revert to the capacity layout which we know fits.
                            return { levels: capacityLayout, N: maxN, topToteHeight: topToteHeightCapacity };
                        }

                        currentBeamBottom = nextBeamBottom;
                        currentToteTop = nextToteTop;
                    }
                }
                
                // If we got here, the even layout fits.
                return { levels: evenLayout, N: maxN, topToteHeight: currentToteTop };
            }

            // --- Main Drawing Function (Elevation View) ---
            function drawElevationView() {
                const dpr = window.devicePixelRatio || 1;

                // --- FIX: Read client dimensions ONCE ---
                const canvasWidth = elevationCanvas.clientWidth;
                const canvasHeight = elevationCanvas.clientHeight;

                if (canvasWidth === 0 || canvasHeight === 0) return;
                
                elevationCanvas.width = canvasWidth * dpr;
                elevationCanvas.height = canvasHeight * dpr;
                elevationCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                elevationCtx.scale(dpr, dpr);
                
                const ctx = elevationCtx;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                // --- Define Viewports ---
                const frontViewWidth = canvasWidth / 2;
                const sideViewWidth = canvasWidth / 2;
                const viewHeight = canvasHeight;
                const frontViewOffsetX = 0;
                const sideViewOffsetX = canvasWidth / 2;
                const padding = 40; // Base padding for both

                // --- 1. Get All Input Values (as numbers) ---
                const inputs = {
                    WH: parseNumber(clearHeightInput.value),
                    BaseHeight: parseNumber(baseBeamHeightInput.value),
                    BW: parseNumber(beamWidthInput.value),
                    TH: parseNumber(toteHeightInput.value),
                    MC: parseNumber(minClearanceInput.value),
                    OC: parseNumber(overheadClearanceInput.value),
                    // Front View
                    UW_front: parseNumber(uprightLengthInput.value), // Map uprightLength to UW
                    NT_front: parseNumber(toteQtyPerBayInput.value), // Map toteQtyPerBay to NT
                    TW_front: parseNumber(toteLengthInput.value),   // Map toteLength to TW (width along beam)
                    TTD_front: parseNumber(toteToToteDistInput.value),
                    TUD_front: parseNumber(toteToUprightDistInput.value),
                    // Side View
                    UW_side: parseNumber(uprightWidthInput.value), // Upright width is the depth
                    TotesDeep: parseNumber(totesDeepSelect.value),
                    ToteDepth: parseNumber(toteWidthInput.value), // Tote width is the depth
                    ToteDepthGap: parseNumber(toteBackToBackDistInput.value),
                    HookAllowance: parseNumber(hookAllowanceInput.value),
                    // Sprinkler
                    SC: parseNumber(sprinklerClearanceInput.value),
                    ST: parseNumber(sprinklerThresholdInput.value)
                };

                // --- 2. Validate Inputs ---
                const elevationInputs = { ...inputs, UW: 0, NT: 0, TW: 0, TTD: 0, TUD: 0 }; // Pass dummy values
                if (Object.values(elevationInputs).some(v => isNaN(v) || v < 0)) {
                    showErrorOnCanvas(ctx, "Please enter valid positive numbers.", canvasWidth, canvasHeight);
                    calculationResults.maxLevels = 0; // Update global state
                    summaryMaxLevels.textContent = '0';
                    return;
                }
                
                const { WH, BaseHeight, BW, TH, MC, OC } = inputs;
                
                if (WH <= (BaseHeight + BW + TH + OC)) {
                    showErrorOnCanvas(ctx, "Height is too small for first level + overhead.", canvasWidth, canvasHeight);
                    calculationResults.maxLevels = 0; // Update global state
                    summaryMaxLevels.textContent = '0';
                    return;
                }

                // --- 3. Calculate SHARED Vertical Layout ---
                const layoutResult = calculateElevationLayout(elevationInputs, true); // True for even distribution
                
                if (!layoutResult || layoutResult.N === 0) {
                    showErrorOnCanvas(ctx, "Could not calculate layout based on inputs.", canvasWidth, canvasHeight);
                    calculationResults.maxLevels = 0; // Update global state
                    summaryMaxLevels.textContent = '0';
                    return;
                }
                
                const { levels, N, topToteHeight } = layoutResult;

                // --- 4. Update Results Display ---
                calculationResults.maxLevels = N; // Update global state
                summaryMaxLevels.textContent = N.toLocaleString('en-US');

                // --- 5. Draw Separator ---
                ctx.strokeStyle = '#cbd5e1'; // slate-300
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvasWidth / 2, 0);
                ctx.lineTo(canvasWidth / 2, canvasHeight);
                ctx.stroke();

                // --- 6. Draw Labels ---
                ctx.fillStyle = '#1e293b'; // slate-800
                ctx.font = 'bold 14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText("Front View", frontViewWidth / 2, padding - 10);
                ctx.fillText("Side View", sideViewOffsetX + sideViewWidth / 2, padding - 10);

                // --- 7.A. DRAW FRONT ELEVATION (LEFT) ---
                {
                    const { UW_front, NT_front, TW_front, TTD_front, TUD_front } = inputs;
                    const NB = 1; // 1 bay
                    const BCO = (NT_front * TW_front) + (Math.max(0, NT_front - 1) * TTD_front) + (2 * TUD_front);
                    const totalRackWidthMM = (NB * BCO) + ((NB + 1) * UW_front);
                    
                    const scaleX = (frontViewWidth - padding * 2) / totalRackWidthMM;
                    const scaleY = (viewHeight - 2 * padding) / WH;
                    const scale = Math.min(scaleX, scaleY);

                    if (scale > 0 && isFinite(scale)) {
                        const uprightWidthPx = UW_front * scale;
                        const bayClearOpeningPx = BCO * scale;
                        const toteWidthPx = TW_front * scale;
                        const toteToToteDistPx = TTD_front * scale;
                        const totalRackWidthPx = totalRackWidthMM * scale;
                        
                        let rackStartX = frontViewOffsetX + (frontViewWidth - totalRackWidthPx) / 2;
                        const y_coord = (mm) => (viewHeight - padding) - (mm * scale);
                        
                        const groundY = y_coord(0);
                        const ceilingY = y_coord(WH);

                        ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(frontViewOffsetX, groundY); ctx.lineTo(frontViewOffsetX + frontViewWidth, groundY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(frontViewOffsetX, ceilingY); ctx.lineTo(frontViewOffsetX + frontViewWidth, ceilingY); ctx.stroke();
                        
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
                        ctx.fillRect(rackStartX, ceilingY, totalRackWidthPx, OC * scale);
                        ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)';
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(rackStartX, ceilingY, totalRackWidthPx, OC * scale);
                        ctx.setLineDash([]);

                        let currentX = rackStartX;
                        const bayStartX = currentX;
                        const bayWidthPx = bayClearOpeningPx + uprightWidthPx;
                        const toteAreaStartX = currentX + uprightWidthPx + TUD_front * scale;

                        ctx.fillStyle = '#94a3b8'; // Left Upright
                        ctx.fillRect(currentX, ceilingY, uprightWidthPx, WH * scale);

                        levels.forEach(level => {
                            const beamY = y_coord(level.beamTop);
                            const beamHeightPx = BW * scale;
                            const toteY = y_coord(level.toteTop);
                            const toteHeightPx = TH * scale;

                            ctx.fillStyle = '#64748b'; // Beam
                            ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
                            ctx.fillRect(bayStartX, beamY, bayWidthPx, beamHeightPx);
                            ctx.strokeRect(bayStartX, beamY, bayWidthPx, beamHeightPx);

                            ctx.fillStyle = '#60a5fa'; // Totes
                            ctx.strokeStyle = '#2563eb';
                            let currentToteX = toteAreaStartX;
                            for (let k = 0; k < NT_front; k++) {
                                ctx.fillRect(currentToteX, toteY, toteWidthPx, toteHeightPx);
                                ctx.strokeRect(currentToteX, toteY, toteWidthPx, toteHeightPx);
                                currentToteX += (toteWidthPx + toteToToteDistPx);
                            }
                            
                            if (level.sprinklerAdded > 0) {
                                const sprinklerBoxY = y_coord(level.toteTop + MC + inputs.SC);
                                const sprinklerBoxHeight = inputs.SC * scale;
                                ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
                                ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                                ctx.setLineDash([4, 4]);
                                ctx.fillRect(bayStartX + uprightWidthPx, sprinklerBoxY, bayClearOpeningPx, sprinklerBoxHeight);
                                ctx.strokeRect(bayStartX + uprightWidthPx, sprinklerBoxY, bayClearOpeningPx, sprinklerBoxHeight);
                                ctx.setLineDash([]);
                            }
                        });
                        
                        currentX += (uprightWidthPx + bayClearOpeningPx);
                        ctx.fillStyle = '#94a3b8'; // Right Upright
                        ctx.fillRect(currentX, ceilingY, uprightWidthPx, WH * scale);
                    }
                }

                // --- 7.B. DRAW SIDE ELEVATION (RIGHT) ---
                {
                    const { UW_side, TotesDeep, ToteDepth, ToteDepthGap, HookAllowance, SC } = inputs;
                    
                    const bayDepth_internal = (TotesDeep * ToteDepth) + (Math.max(0, TotesDeep - 1) * ToteDepthGap) + HookAllowance;
                    const totalRackWidthMM = bayDepth_internal + (2 * UW_side); // Add front and back uprights

                    const scaleX = (sideViewWidth - padding * 2) / totalRackWidthMM;
                    const scaleY = (viewHeight - 2 * padding) / WH;
                    const scale = Math.min(scaleX, scaleY);

                    if (scale > 0 && isFinite(scale)) {
                        const uprightWidthPx = UW_side * scale;
                        const totalRackWidthPx = totalRackWidthMM * scale;
                        const toteDepthPx = ToteDepth * scale;
                        const toteDepthGapPx = ToteDepthGap * scale;
                        
                        let rackStartX = sideViewOffsetX + (sideViewWidth - totalRackWidthPx) / 2;
                        const y_coord = (mm) => (viewHeight - padding) - (mm * scale);

                        const groundY = y_coord(0);
                        const ceilingY = y_coord(WH);

                        ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(sideViewOffsetX, groundY); ctx.lineTo(sideViewOffsetX + sideViewWidth, groundY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(sideViewOffsetX, ceilingY); ctx.lineTo(sideViewOffsetX + sideViewWidth, ceilingY); ctx.stroke();
                        
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
                        ctx.fillRect(rackStartX, ceilingY, totalRackWidthPx, OC * scale);
                        ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)';
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(rackStartX, ceilingY, totalRackWidthPx, OC * scale);
                        ctx.setLineDash([]);

                        const toteAreaStartX = rackStartX + uprightWidthPx;

                        ctx.fillStyle = '#94a3b8'; // Left Upright (Front)
                        ctx.fillRect(rackStartX, ceilingY, uprightWidthPx, WH * scale);

                        levels.forEach(level => {
                            const toteY = y_coord(level.toteTop);
                            const toteHeightPx = TH * scale;

                            ctx.fillStyle = '#60a5fa'; // Totes
                            ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 0.5;
                            let currentToteX = toteAreaStartX;
                            for (let k = 0; k < TotesDeep; k++) {
                                ctx.fillRect(currentToteX, toteY, toteDepthPx, toteHeightPx);
                                ctx.strokeRect(currentToteX, toteY, toteDepthPx, toteHeightPx);
                                currentToteX += (toteDepthPx + toteDepthGapPx);
                            }
                            
                            if (level.sprinklerAdded > 0) {
                                const sprinklerBoxY = y_coord(level.toteTop + MC + SC);
                                const sprinklerBoxHeight = SC * scale;
                                const internalWidthPx = totalRackWidthPx - (2 * uprightWidthPx);
                                
                                ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
                                ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                                ctx.setLineDash([4, 4]);
                                ctx.fillRect(rackStartX + uprightWidthPx, sprinklerBoxY, internalWidthPx, sprinklerBoxHeight);
                                ctx.strokeRect(rackStartX + uprightWidthPx, sprinklerBoxY, internalWidthPx, sprinklerBoxHeight);
                                ctx.setLineDash([]);
                            }
                        });
                        
                        const rightUprightX = rackStartX + totalRackWidthPx - uprightWidthPx;
                        ctx.fillStyle = '#94a3b8'; // Right Upright (Back)
                        ctx.fillRect(rightUprightX, ceilingY, uprightWidthPx, WH * scale);
                    }
                }
            }

            function showErrorOnCanvas(ctx, message, canvasWidth, canvasHeight) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.save();
                ctx.font = '16px Inter, sans-serif';
                ctx.fillStyle = '#dc2626'; // red-600
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(message, canvasWidth / 2, canvasHeight / 2);
                ctx.restore();
            }

            // --- NEW: Function to calculate combined results ---
            function updateCombinedResults() {
                const { totalBays, maxLevels } = calculationResults;

                if (totalBays === 0 || maxLevels === 0) {
                    summaryTotalLocations.textContent = '0';
                    return;
                }

                const totesPerBay_horiz = parseNumber(toteQtyPerBayInput.value) || 1;
                const totesDeep = parseNumber(totesDeepSelect.value) || 1;

                const totalLocations = totalBays * maxLevels * totesPerBay_horiz * totesDeep;
                
                summaryTotalLocations.textContent = totalLocations.toLocaleString('en-US');
            }


            // --- Debounced Draw Function ---
            function requestRedraw() {
                if (rafId) {
                    cancelAnimationFrame(rafId);
                }
                rafId = requestAnimationFrame(() => {
                    drawWarehouse();        // This updates calculationResults.totalBays
                    drawRackDetail();       // This one just draws
                    drawElevationView();    // This updates calculationResults.maxLevels & draws both elevations
                    updateCombinedResults(); // This uses both results to calc locations
                    rafId = null; 
                });
            }

            // --- Event Listeners ---
            
            // Redraw on input change
            redrawInputs.forEach(input => {
                input.addEventListener('input', requestRedraw);
            });

            // Handle layout mode change
            layoutModeSelect.addEventListener('change', () => {
                toggleFlueSpace();
                requestRedraw(); 
            });

             // Apply number formatting on 'blur'
            numberInputs.forEach(input => {
                input.value = formatNumber(input.value); // Format initial
                input.addEventListener('blur', () => {
                    input.value = formatNumber(input.value);
                });
            });

            // Redraw on window resize
            const resizeObserver = new ResizeObserver(requestRedraw);
            // Observe all canvas parent containers
            resizeObserver.observe(warehouseCanvas.parentElement);
            resizeObserver.observe(rackDetailCanvas.parentElement);
            resizeObserver.observe(elevationCanvas.parentElement); // Add new canvas

            // --- NEW: Main Tab switching logic ---
            mainViewTabs.addEventListener('click', (e) => {
                if (e.target.classList.contains('main-tab-button')) {
                    // Deactivate all main tabs
                    mainViewTabs.querySelectorAll('.main-tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.main-tab-content').forEach(content => content.classList.remove('active'));
                    
                    // Activate clicked
                    e.target.classList.add('active');
                    const tabId = e.target.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');

                    // Request a redraw to ensure the newly visible canvas is drawn
                    requestRedraw();
                }
            });

            // --- Renamed: Sub-Tab switching logic (within Viz) ---
            viewSubTabs.addEventListener('click', (e) => {
                if (e.target.classList.contains('sub-tab-button')) {
                    // Deactivate all sub-tabs
                    viewSubTabs.querySelectorAll('.sub-tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.sub-tab-content').forEach(content => content.classList.remove('active'));
                    
                    // Activate clicked
                    e.target.classList.add('active');
                    const tabId = e.target.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');

                    // Request a redraw to ensure the newly visible canvas is drawn
                    requestRedraw();
                }
            });


            // --- NEW: Solver Logic ---

            // Solver helper function to run the full calculation engine
            function getMetrics(systemLength, systemWidth) {
                // 1. Get all config inputs
                const toteWidth = parseNumber(toteWidthInput.value) || 0;
                const toteLength = parseNumber(toteLengthInput.value) || 0;
                const toteQtyPerBay = parseNumber(toteQtyPerBayInput.value) || 1;
                const totesDeep = parseNumber(totesDeepSelect.value) || 1;
                const toteToToteDist = parseNumber(toteToToteDistInput.value) || 0;
                const toteToUprightDist = parseNumber(toteToUprightDistInput.value) || 0;
                const toteBackToBackDist = parseNumber(toteBackToBackDistInput.value) || 0;
                const uprightLength = parseNumber(uprightLengthInput.value) || 0;
                const uprightWidth = parseNumber(uprightWidthInput.value) || 0;
                const hookAllowance = parseNumber(hookAllowanceInput.value) || 0;
                const aisleWidth = parseNumber(aisleWidthInput.value) || 0;
                const setbackTop = parseNumber(setbackTopInput.value) || 0;
                const setbackBottom = parseNumber(setbackBottomInput.value) || 0;
                const layoutMode = layoutModeSelect.value;
                const flueSpace = parseNumber(flueSpaceInput.value) || 0;

                // 2. Calculate bay dims (from drawWarehouse)
                const bayWidth = (toteQtyPerBay * toteLength) + (2 * toteToUprightDist) + (Math.max(0, toteQtyPerBay - 1) * toteToToteDist) + (uprightLength * 2);
                const bayDepth = (totesDeep * toteWidth) + (Math.max(0, totesDeep - 1) * toteBackToBackDist) + hookAllowance;

                // 3. Call Top-Down Layout
                const layout = calculateLayout(bayWidth, bayDepth, aisleWidth, systemLength, systemWidth, layoutMode, flueSpace, setbackTop, setbackBottom);
                const totalBays = layout.totalBays;

                // 4. Get Elevation Inputs
                const elevInputs = {
                    WH: parseNumber(clearHeightInput.value),
                    BaseHeight: parseNumber(baseBeamHeightInput.value),
                    BW: parseNumber(beamWidthInput.value),
                    TH: parseNumber(toteHeightInput.value),
                    MC: parseNumber(minClearanceInput.value),
                    OC: parseNumber(overheadClearanceInput.value),
                    SC: parseNumber(sprinklerClearanceInput.value),
                    ST: parseNumber(sprinklerThresholdInput.value)
                };
                
                // 5. Call Elevation Layout
                const layoutResult = calculateElevationLayout(elevInputs, true);
                const maxLevels = (layoutResult && layoutResult.N > 0) ? layoutResult.N : 0;

                // 7. Calculate Final Metrics
                const totalLocations = totalBays * maxLevels * toteQtyPerBay * totesDeep;
                const footprint = (systemLength / 1000) * (systemWidth / 1000);
                
                return { totalBays, maxLevels, totalLocations, footprint, L: systemLength, W: systemWidth };
            }

            // --- Solver Modal Controls ---
            function showSolverModal(message) {
                solverModalMessage.textContent = message;
                solverModal.style.display = 'flex';
            }
            function hideSolverModal() {
                solverModal.style.display = 'none';
            }

            function updateSolverResults(results) {
                solverResultLength.textContent = formatNumber(results.L);
                solverResultWidth.textContent = formatNumber(results.W);
                solverResultFootprint.textContent = results.footprint.toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
                solverResultLocations.textContent = formatNumber(results.totalLocations);
                solverResultPerfDensity.textContent = (results.density || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                
                solverFinalResults = results; // Store for the "Apply" button
                applySolverButton.style.display = 'block';
            }

            // --- Solver Main Function ---
            async function runSolver(continueForPerformance = false) {
                runSolverButton.disabled = true;
                applySolverButton.style.display = 'none';

                const storageReq = parseNumber(solverStorageReqInput.value);
                const throughputReq = parseNumber(solverThroughputReqInput.value);
                const aspectRatio = parseNumber(solverAspectRatioInput.value) || 1.0;
                const maxDensity = parseNumber(solverMaxPerfDensityInput.value) || 50;

                if (storageReq === 0 || throughputReq === 0 || aspectRatio === 0) {
                    solverStatus.textContent = "Error: Please check solver inputs.";
                    runSolverButton.disabled = false;
                    return;
                }

                let currentL = continueForPerformance ? solverTempResults.L : 10000; // Start at 10m
                const step = 1000; // 1m steps
                let safetyBreak = continueForPerformance ? 200 : 100; // 200m or 100m
                let storageMetResults = continueForPerformance ? solverTempResults : null;

                if (continueForPerformance) {
                    solverStatus.textContent = "Solving for performance...";
                } else {
                    solverStatus.textContent = "Solving for storage...";
                }

                // Use requestAnimationFrame to avoid blocking the UI
                function solverLoop() {
                    let metrics;
                    if (!continueForPerformance) {
                        // --- Loop 1: Find Storage ---
                        currentL += step;
                        let currentW = currentL / aspectRatio;
                        metrics = getMetrics(currentL, currentW);

                        if (metrics.totalLocations >= storageReq) {
                            // Found storage target
                            storageMetResults = { ...metrics, density: throughputReq / metrics.footprint };
                            solverTempResults = storageMetResults; // Save for modal
                            
                            if (storageMetResults.density > maxDensity) {
                                // Storage met, but density is too high
                                const msg = `Storage target met at ${formatNumber(metrics.totalLocations)} locations. However, performance density is ${storageMetResults.density.toFixed(1)} (target: ${maxDensity}). Continue expanding to meet performance target?`;
                                showSolverModal(msg);
                                // Stop the loop, modal buttons will take over
                                runSolverButton.disabled = false; // Re-enable button
                                return; 
                            } else {
                                // Storage and performance met in one go!
                                updateSolverResults(storageMetResults);
                                solverStatus.textContent = "Complete.";
                                runSolverButton.disabled = false;
                                return;
                            }
                        }
                    } else {
                        // --- Loop 2: Find Performance ---
                        currentL += step;
                        let currentW = currentL / aspectRatio;
                        metrics = getMetrics(currentL, currentW);
                        let density = (metrics.footprint > 0) ? throughputReq / metrics.footprint : 0;

                        if (density <= maxDensity) {
                            // Performance target met
                            updateSolverResults({ ...metrics, density: density });
                            solverStatus.textContent = "Complete.";
                            runSolverButton.disabled = false;
                            return;
                        }
                    }

                    // Check safety break
                    if (currentL > (safetyBreak * 1000)) {
                        solverStatus.textContent = `Error: No solution found under ${safetyBreak}m.`;
                        runSolverButton.disabled = false;
                        return;
                    }

                    // Continue loop
                    requestAnimationFrame(solverLoop);
                }

                // Start the first iteration
                requestAnimationFrame(solverLoop);
            }
            
            runSolverButton.addEventListener('click', () => runSolver(false));

            solverModalStop.addEventListener('click', () => {
                hideSolverModal();
                updateSolverResults(solverTempResults); // Use the stored storage-met results
                solverStatus.textContent = "Complete (Storage target met).";
                runSolverButton.disabled = false;
            });

            solverModalContinue.addEventListener('click', () => {
                hideSolverModal();
                runSolver(true); // Start part 2
            });

            solverModalBackdrop.addEventListener('click', hideSolverModal);

            applySolverButton.addEventListener('click', () => {
                if (solverFinalResults) {
                    systemLengthInput.value = formatNumber(solverFinalResults.L);
                    systemWidthInput.value = formatNumber(solverFinalResults.W);
                    
                    // Switch to config tab to show the change
                    mainViewTabs.querySelector('[data-tab="configTabContent"]').click();
                    
                    // Trigger a redraw with the new values
                    requestRedraw();
                }
            });


            // --- Initial Setup ---
            toggleFlueSpace();
            // Initial draw is handled by the ResizeObservers
        });
    </script>
</body>
</html>